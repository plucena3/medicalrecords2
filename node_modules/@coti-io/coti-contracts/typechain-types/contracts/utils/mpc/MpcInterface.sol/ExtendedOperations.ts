/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "../../../../common";

export interface ExtendedOperationsInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "Add"
      | "And"
      | "Decrypt"
      | "Div"
      | "Eq"
      | "Ge"
      | "GetUserKey"
      | "Gt"
      | "Le"
      | "Lt"
      | "Max"
      | "Min"
      | "Mul"
      | "Mux"
      | "Ne"
      | "Not"
      | "OffBoard"
      | "OffBoardToUser"
      | "OnBoard"
      | "Or"
      | "Rand"
      | "RandBoundedBits"
      | "Rem"
      | "SetPublic"
      | "Shl"
      | "Shr"
      | "Sub"
      | "Transfer"
      | "TransferWithAllowance"
      | "ValidateCiphertext"
      | "Xor"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "Add",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "And",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "Decrypt",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "Div",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "Eq",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "Ge",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "GetUserKey",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "Gt",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "Le",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "Lt",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "Max",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "Min",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "Mul",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "Mux",
    values: [BytesLike, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "Ne",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "Not",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "OffBoard",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "OffBoardToUser",
    values: [BytesLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "OnBoard",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "Or",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "Rand", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "RandBoundedBits",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "Rem",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "SetPublic",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "Shl",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "Shr",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "Sub",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "Transfer",
    values: [BytesLike, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "TransferWithAllowance",
    values: [BytesLike, BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "ValidateCiphertext",
    values: [BytesLike, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "Xor",
    values: [BytesLike, BigNumberish, BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "Add", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "And", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Decrypt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Div", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Eq", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Ge", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "GetUserKey", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Gt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Le", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Lt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Max", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Min", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Mul", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Mux", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Ne", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Not", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "OffBoard", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "OffBoardToUser",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "OnBoard", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Or", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Rand", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "RandBoundedBits",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "Rem", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "SetPublic", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Shl", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Shr", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Sub", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "Transfer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "TransferWithAllowance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "ValidateCiphertext",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "Xor", data: BytesLike): Result;
}

export interface ExtendedOperations extends BaseContract {
  connect(runner?: ContractRunner | null): ExtendedOperations;
  waitForDeployment(): Promise<this>;

  interface: ExtendedOperationsInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    listener: TypedListener<TCEvent>
  ): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(
    event?: TCEvent
  ): Promise<this>;

  Add: TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  And: TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  Decrypt: TypedContractMethod<
    [metaData: BytesLike, a: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  Div: TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  Eq: TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  Ge: TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  GetUserKey: TypedContractMethod<[signedEK: BytesLike], [string], "view">;

  Gt: TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  Le: TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  Lt: TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  Max: TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  Min: TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  Mul: TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  Mux: TypedContractMethod<
    [metaData: BytesLike, bit: BigNumberish, a: BigNumberish, b: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  Ne: TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  Not: TypedContractMethod<
    [metaData: BytesLike, a: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  OffBoard: TypedContractMethod<
    [metaData: BytesLike, ct: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  OffBoardToUser: TypedContractMethod<
    [metaData: BytesLike, ct: BigNumberish, addr: BytesLike],
    [bigint],
    "nonpayable"
  >;

  OnBoard: TypedContractMethod<
    [metaData: BytesLike, ct: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  Or: TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  Rand: TypedContractMethod<[metaData: BytesLike], [bigint], "nonpayable">;

  RandBoundedBits: TypedContractMethod<
    [metaData: BytesLike, numBits: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  Rem: TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  SetPublic: TypedContractMethod<
    [metaData: BytesLike, ct: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  Shl: TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  Shr: TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  Sub: TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  Transfer: TypedContractMethod<
    [
      metaData: BytesLike,
      a: BigNumberish,
      b: BigNumberish,
      amount: BigNumberish
    ],
    [[bigint, bigint, bigint] & { new_a: bigint; new_b: bigint; res: bigint }],
    "nonpayable"
  >;

  TransferWithAllowance: TypedContractMethod<
    [
      metaData: BytesLike,
      a: BigNumberish,
      b: BigNumberish,
      amount: BigNumberish,
      allowance: BigNumberish
    ],
    [
      [bigint, bigint, bigint, bigint] & {
        new_a: bigint;
        new_b: bigint;
        res: bigint;
        new_allowance: bigint;
      }
    ],
    "nonpayable"
  >;

  ValidateCiphertext: TypedContractMethod<
    [metaData: BytesLike, ciphertext: BigNumberish, signature: BytesLike],
    [bigint],
    "nonpayable"
  >;

  Xor: TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(
    key: string | FunctionFragment
  ): T;

  getFunction(
    nameOrSignature: "Add"
  ): TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "And"
  ): TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "Decrypt"
  ): TypedContractMethod<
    [metaData: BytesLike, a: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "Div"
  ): TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "Eq"
  ): TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "Ge"
  ): TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "GetUserKey"
  ): TypedContractMethod<[signedEK: BytesLike], [string], "view">;
  getFunction(
    nameOrSignature: "Gt"
  ): TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "Le"
  ): TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "Lt"
  ): TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "Max"
  ): TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "Min"
  ): TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "Mul"
  ): TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "Mux"
  ): TypedContractMethod<
    [metaData: BytesLike, bit: BigNumberish, a: BigNumberish, b: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "Ne"
  ): TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "Not"
  ): TypedContractMethod<
    [metaData: BytesLike, a: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "OffBoard"
  ): TypedContractMethod<
    [metaData: BytesLike, ct: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "OffBoardToUser"
  ): TypedContractMethod<
    [metaData: BytesLike, ct: BigNumberish, addr: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "OnBoard"
  ): TypedContractMethod<
    [metaData: BytesLike, ct: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "Or"
  ): TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "Rand"
  ): TypedContractMethod<[metaData: BytesLike], [bigint], "nonpayable">;
  getFunction(
    nameOrSignature: "RandBoundedBits"
  ): TypedContractMethod<
    [metaData: BytesLike, numBits: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "Rem"
  ): TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "SetPublic"
  ): TypedContractMethod<
    [metaData: BytesLike, ct: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "Shl"
  ): TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "Shr"
  ): TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "Sub"
  ): TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "Transfer"
  ): TypedContractMethod<
    [
      metaData: BytesLike,
      a: BigNumberish,
      b: BigNumberish,
      amount: BigNumberish
    ],
    [[bigint, bigint, bigint] & { new_a: bigint; new_b: bigint; res: bigint }],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "TransferWithAllowance"
  ): TypedContractMethod<
    [
      metaData: BytesLike,
      a: BigNumberish,
      b: BigNumberish,
      amount: BigNumberish,
      allowance: BigNumberish
    ],
    [
      [bigint, bigint, bigint, bigint] & {
        new_a: bigint;
        new_b: bigint;
        res: bigint;
        new_allowance: bigint;
      }
    ],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "ValidateCiphertext"
  ): TypedContractMethod<
    [metaData: BytesLike, ciphertext: BigNumberish, signature: BytesLike],
    [bigint],
    "nonpayable"
  >;
  getFunction(
    nameOrSignature: "Xor"
  ): TypedContractMethod<
    [metaData: BytesLike, lhs: BigNumberish, rhs: BigNumberish],
    [bigint],
    "nonpayable"
  >;

  filters: {};
}
